[{"path":"https://davidrach.github.io/Coereba/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"GNU Affero General Public License","title":"GNU Affero General Public License","text":"Version 3, 19 November 2007 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/> Everyone permitted copy distribute verbatim copies license document, changing allowed.","code":""},{"path":"https://davidrach.github.io/Coereba/LICENSE.html","id":"preamble","dir":"","previous_headings":"","what":"Preamble","title":"GNU Affero General Public License","text":"GNU Affero General Public License free, copyleft license software kinds works, specifically designed ensure cooperation community case network server software. licenses software practical works designed take away freedom share change works. contrast, General Public Licenses intended guarantee freedom share change versions program–make sure remains free software users. speak free software, referring freedom, price. General Public Licenses designed make sure freedom distribute copies free software (charge wish), receive source code can get want , can change software use pieces new free programs, know can things. Developers use General Public Licenses protect rights two steps: (1) assert copyright software, (2) offer License gives legal permission copy, distribute /modify software. secondary benefit defending users’ freedom improvements made alternate versions program, receive widespread use, become available developers incorporate. Many developers free software heartened encouraged resulting cooperation. However, case software used network servers, result may fail come . GNU General Public License permits making modified version letting public access server without ever releasing source code public. GNU Affero General Public License designed specifically ensure , cases, modified source code becomes available community. requires operator network server provide source code modified version running users server. Therefore, public use modified version, publicly accessible server, gives public access source code modified version. older license, called Affero General Public License published Affero, designed accomplish similar goals. different license, version Affero GPL, Affero released new version Affero GPL permits relicensing license. precise terms conditions copying, distribution modification follow.","code":""},{"path":[]},{"path":"https://davidrach.github.io/Coereba/LICENSE.html","id":"0-definitions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"0. Definitions.","title":"GNU Affero General Public License","text":"“License” refers version 3 GNU Affero General Public License. “Copyright” also means copyright-like laws apply kinds works, semiconductor masks. “Program” refers copyrightable work licensed License. licensee addressed “”. “Licensees” “recipients” may individuals organizations. “modify” work means copy adapt part work fashion requiring copyright permission, making exact copy. resulting work called “modified version” earlier work work “based ” earlier work. “covered work” means either unmodified Program work based Program. “propagate” work means anything , without permission, make directly secondarily liable infringement applicable copyright law, except executing computer modifying private copy. Propagation includes copying, distribution (without modification), making available public, countries activities well. “convey” work means kind propagation enables parties make receive copies. Mere interaction user computer network, transfer copy, conveying. interactive user interface displays “Appropriate Legal Notices” extent includes convenient prominently visible feature (1) displays appropriate copyright notice, (2) tells user warranty work (except extent warranties provided), licensees may convey work License, view copy License. interface presents list user commands options, menu, prominent item list meets criterion.","code":""},{"path":"https://davidrach.github.io/Coereba/LICENSE.html","id":"1-source-code","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"1. Source Code.","title":"GNU Affero General Public License","text":"“source code” work means preferred form work making modifications . “Object code” means non-source form work. “Standard Interface” means interface either official standard defined recognized standards body, , case interfaces specified particular programming language, one widely used among developers working language. “System Libraries” executable work include anything, work whole, () included normal form packaging Major Component, part Major Component, (b) serves enable use work Major Component, implement Standard Interface implementation available public source code form. “Major Component”, context, means major essential component (kernel, window system, ) specific operating system () executable work runs, compiler used produce work, object code interpreter used run . “Corresponding Source” work object code form means source code needed generate, install, (executable work) run object code modify work, including scripts control activities. However, include work’s System Libraries, general-purpose tools generally available free programs used unmodified performing activities part work. example, Corresponding Source includes interface definition files associated source files work, source code shared libraries dynamically linked subprograms work specifically designed require, intimate data communication control flow subprograms parts work. Corresponding Source need include anything users can regenerate automatically parts Corresponding Source. Corresponding Source work source code form work.","code":""},{"path":"https://davidrach.github.io/Coereba/LICENSE.html","id":"2-basic-permissions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"2. Basic Permissions.","title":"GNU Affero General Public License","text":"rights granted License granted term copyright Program, irrevocable provided stated conditions met. License explicitly affirms unlimited permission run unmodified Program. output running covered work covered License output, given content, constitutes covered work. License acknowledges rights fair use equivalent, provided copyright law. may make, run propagate covered works convey, without conditions long license otherwise remains force. may convey covered works others sole purpose make modifications exclusively , provide facilities running works, provided comply terms License conveying material control copyright. thus making running covered works must exclusively behalf, direction control, terms prohibit making copies copyrighted material outside relationship . Conveying circumstances permitted solely conditions stated . Sublicensing allowed; section 10 makes unnecessary.","code":""},{"path":"https://davidrach.github.io/Coereba/LICENSE.html","id":"3-protecting-users-legal-rights-from-anti-circumvention-law","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"3. Protecting Users’ Legal Rights From Anti-Circumvention Law.","title":"GNU Affero General Public License","text":"covered work shall deemed part effective technological measure applicable law fulfilling obligations article 11 WIPO copyright treaty adopted 20 December 1996, similar laws prohibiting restricting circumvention measures. convey covered work, waive legal power forbid circumvention technological measures extent circumvention effected exercising rights License respect covered work, disclaim intention limit operation modification work means enforcing, work’s users, third parties’ legal rights forbid circumvention technological measures.","code":""},{"path":"https://davidrach.github.io/Coereba/LICENSE.html","id":"4-conveying-verbatim-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"4. Conveying Verbatim Copies.","title":"GNU Affero General Public License","text":"may convey verbatim copies Program’s source code receive , medium, provided conspicuously appropriately publish copy appropriate copyright notice; keep intact notices stating License non-permissive terms added accord section 7 apply code; keep intact notices absence warranty; give recipients copy License along Program. may charge price price copy convey, may offer support warranty protection fee.","code":""},{"path":"https://davidrach.github.io/Coereba/LICENSE.html","id":"5-conveying-modified-source-versions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"5. Conveying Modified Source Versions.","title":"GNU Affero General Public License","text":"may convey work based Program, modifications produce Program, form source code terms section 4, provided also meet conditions: work must carry prominent notices stating modified , giving relevant date. work must carry prominent notices stating released License conditions added section 7. requirement modifies requirement section 4 “keep intact notices”. must license entire work, whole, License anyone comes possession copy. License therefore apply, along applicable section 7 additional terms, whole work, parts, regardless packaged. License gives permission license work way, invalidate permission separately received . work interactive user interfaces, must display Appropriate Legal Notices; however, Program interactive interfaces display Appropriate Legal Notices, work need make . compilation covered work separate independent works, nature extensions covered work, combined form larger program, volume storage distribution medium, called “aggregate” compilation resulting copyright used limit access legal rights compilation’s users beyond individual works permit. Inclusion covered work aggregate cause License apply parts aggregate.","code":""},{"path":"https://davidrach.github.io/Coereba/LICENSE.html","id":"6-conveying-non-source-forms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"6. Conveying Non-Source Forms.","title":"GNU Affero General Public License","text":"may convey covered work object code form terms sections 4 5, provided also convey machine-readable Corresponding Source terms License, one ways: Convey object code , embodied , physical product (including physical distribution medium), accompanied Corresponding Source fixed durable physical medium customarily used software interchange. Convey object code , embodied , physical product (including physical distribution medium), accompanied written offer, valid least three years valid long offer spare parts customer support product model, give anyone possesses object code either (1) copy Corresponding Source software product covered License, durable physical medium customarily used software interchange, price reasonable cost physically performing conveying source, (2) access copy Corresponding Source network server charge. Convey individual copies object code copy written offer provide Corresponding Source. alternative allowed occasionally noncommercially, received object code offer, accord subsection 6b. Convey object code offering access designated place (gratis charge), offer equivalent access Corresponding Source way place charge. need require recipients copy Corresponding Source along object code. place copy object code network server, Corresponding Source may different server (operated third party) supports equivalent copying facilities, provided maintain clear directions next object code saying find Corresponding Source. Regardless server hosts Corresponding Source, remain obligated ensure available long needed satisfy requirements. Convey object code using peer--peer transmission, provided inform peers object code Corresponding Source work offered general public charge subsection 6d. separable portion object code, whose source code excluded Corresponding Source System Library, need included conveying object code work. “User Product” either (1) “consumer product”, means tangible personal property normally used personal, family, household purposes, (2) anything designed sold incorporation dwelling. determining whether product consumer product, doubtful cases shall resolved favor coverage. particular product received particular user, “normally used” refers typical common use class product, regardless status particular user way particular user actually uses, expects expected use, product. product consumer product regardless whether product substantial commercial, industrial non-consumer uses, unless uses represent significant mode use product. “Installation Information” User Product means methods, procedures, authorization keys, information required install execute modified versions covered work User Product modified version Corresponding Source. information must suffice ensure continued functioning modified object code case prevented interfered solely modification made. convey object code work section , , specifically use , User Product, conveying occurs part transaction right possession use User Product transferred recipient perpetuity fixed term (regardless transaction characterized), Corresponding Source conveyed section must accompanied Installation Information. requirement apply neither third party retains ability install modified object code User Product (example, work installed ROM). requirement provide Installation Information include requirement continue provide support service, warranty, updates work modified installed recipient, User Product modified installed. Access network may denied modification materially adversely affects operation network violates rules protocols communication across network. Corresponding Source conveyed, Installation Information provided, accord section must format publicly documented (implementation available public source code form), must require special password key unpacking, reading copying.","code":""},{"path":"https://davidrach.github.io/Coereba/LICENSE.html","id":"7-additional-terms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"7. Additional Terms.","title":"GNU Affero General Public License","text":"“Additional permissions” terms supplement terms License making exceptions one conditions. Additional permissions applicable entire Program shall treated though included License, extent valid applicable law. additional permissions apply part Program, part may used separately permissions, entire Program remains governed License without regard additional permissions. convey copy covered work, may option remove additional permissions copy, part . (Additional permissions may written require removal certain cases modify work.) may place additional permissions material, added covered work, can give appropriate copyright permission. Notwithstanding provision License, material add covered work, may (authorized copyright holders material) supplement terms License terms: Disclaiming warranty limiting liability differently terms sections 15 16 License; Requiring preservation specified reasonable legal notices author attributions material Appropriate Legal Notices displayed works containing ; Prohibiting misrepresentation origin material, requiring modified versions material marked reasonable ways different original version; Limiting use publicity purposes names licensors authors material; Declining grant rights trademark law use trade names, trademarks, service marks; Requiring indemnification licensors authors material anyone conveys material (modified versions ) contractual assumptions liability recipient, liability contractual assumptions directly impose licensors authors. non-permissive additional terms considered “restrictions” within meaning section 10. Program received , part , contains notice stating governed License along term restriction, may remove term. license document contains restriction permits relicensing conveying License, may add covered work material governed terms license document, provided restriction survive relicensing conveying. add terms covered work accord section, must place, relevant source files, statement additional terms apply files, notice indicating find applicable terms. Additional terms, permissive non-permissive, may stated form separately written license, stated exceptions; requirements apply either way.","code":""},{"path":"https://davidrach.github.io/Coereba/LICENSE.html","id":"8-termination","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"8. Termination.","title":"GNU Affero General Public License","text":"may propagate modify covered work except expressly provided License. attempt otherwise propagate modify void, automatically terminate rights License (including patent licenses granted third paragraph section 11). However, cease violation License, license particular copyright holder reinstated () provisionally, unless copyright holder explicitly finally terminates license, (b) permanently, copyright holder fails notify violation reasonable means prior 60 days cessation. Moreover, license particular copyright holder reinstated permanently copyright holder notifies violation reasonable means, first time received notice violation License (work) copyright holder, cure violation prior 30 days receipt notice. Termination rights section terminate licenses parties received copies rights License. rights terminated permanently reinstated, qualify receive new licenses material section 10.","code":""},{"path":"https://davidrach.github.io/Coereba/LICENSE.html","id":"9-acceptance-not-required-for-having-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"9. Acceptance Not Required for Having Copies.","title":"GNU Affero General Public License","text":"required accept License order receive run copy Program. Ancillary propagation covered work occurring solely consequence using peer--peer transmission receive copy likewise require acceptance. However, nothing License grants permission propagate modify covered work. actions infringe copyright accept License. Therefore, modifying propagating covered work, indicate acceptance License .","code":""},{"path":"https://davidrach.github.io/Coereba/LICENSE.html","id":"10-automatic-licensing-of-downstream-recipients","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"10. Automatic Licensing of Downstream Recipients.","title":"GNU Affero General Public License","text":"time convey covered work, recipient automatically receives license original licensors, run, modify propagate work, subject License. responsible enforcing compliance third parties License. “entity transaction” transaction transferring control organization, substantially assets one, subdividing organization, merging organizations. propagation covered work results entity transaction, party transaction receives copy work also receives whatever licenses work party’s predecessor interest give previous paragraph, plus right possession Corresponding Source work predecessor interest, predecessor can get reasonable efforts. may impose restrictions exercise rights granted affirmed License. example, may impose license fee, royalty, charge exercise rights granted License, may initiate litigation (including cross-claim counterclaim lawsuit) alleging patent claim infringed making, using, selling, offering sale, importing Program portion .","code":""},{"path":"https://davidrach.github.io/Coereba/LICENSE.html","id":"11-patents","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"11. Patents.","title":"GNU Affero General Public License","text":"“contributor” copyright holder authorizes use License Program work Program based. work thus licensed called contributor’s “contributor version”. contributor’s “essential patent claims” patent claims owned controlled contributor, whether already acquired hereafter acquired, infringed manner, permitted License, making, using, selling contributor version, include claims infringed consequence modification contributor version. purposes definition, “control” includes right grant patent sublicenses manner consistent requirements License. contributor grants non-exclusive, worldwide, royalty-free patent license contributor’s essential patent claims, make, use, sell, offer sale, import otherwise run, modify propagate contents contributor version. following three paragraphs, “patent license” express agreement commitment, however denominated, enforce patent (express permission practice patent covenant sue patent infringement). “grant” patent license party means make agreement commitment enforce patent party. convey covered work, knowingly relying patent license, Corresponding Source work available anyone copy, free charge terms License, publicly available network server readily accessible means, must either (1) cause Corresponding Source available, (2) arrange deprive benefit patent license particular work, (3) arrange, manner consistent requirements License, extend patent license downstream recipients. “Knowingly relying” means actual knowledge , patent license, conveying covered work country, recipient’s use covered work country, infringe one identifiable patents country reason believe valid. , pursuant connection single transaction arrangement, convey, propagate procuring conveyance , covered work, grant patent license parties receiving covered work authorizing use, propagate, modify convey specific copy covered work, patent license grant automatically extended recipients covered work works based . patent license “discriminatory” include within scope coverage, prohibits exercise , conditioned non-exercise one rights specifically granted License. may convey covered work party arrangement third party business distributing software, make payment third party based extent activity conveying work, third party grants, parties receive covered work , discriminatory patent license () connection copies covered work conveyed (copies made copies), (b) primarily connection specific products compilations contain covered work, unless entered arrangement, patent license granted, prior 28 March 2007. Nothing License shall construed excluding limiting implied license defenses infringement may otherwise available applicable patent law.","code":""},{"path":"https://davidrach.github.io/Coereba/LICENSE.html","id":"12-no-surrender-of-others-freedom","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"12. No Surrender of Others’ Freedom.","title":"GNU Affero General Public License","text":"conditions imposed (whether court order, agreement otherwise) contradict conditions License, excuse conditions License. convey covered work satisfy simultaneously obligations License pertinent obligations, consequence may convey . example, agree terms obligate collect royalty conveying convey Program, way satisfy terms License refrain entirely conveying Program.","code":""},{"path":"https://davidrach.github.io/Coereba/LICENSE.html","id":"13-remote-network-interaction-use-with-the-gnu-general-public-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"13. Remote Network Interaction; Use with the GNU General Public License.","title":"GNU Affero General Public License","text":"Notwithstanding provision License, modify Program, modified version must prominently offer users interacting remotely computer network (version supports interaction) opportunity receive Corresponding Source version providing access Corresponding Source network server charge, standard customary means facilitating copying software. Corresponding Source shall include Corresponding Source work covered version 3 GNU General Public License incorporated pursuant following paragraph. Notwithstanding provision License, permission link combine covered work work licensed version 3 GNU General Public License single combined work, convey resulting work. terms License continue apply part covered work, work combined remain governed version 3 GNU General Public License.","code":""},{"path":"https://davidrach.github.io/Coereba/LICENSE.html","id":"14-revised-versions-of-this-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"14. Revised Versions of this License.","title":"GNU Affero General Public License","text":"Free Software Foundation may publish revised /new versions GNU Affero General Public License time time. new versions similar spirit present version, may differ detail address new problems concerns. version given distinguishing version number. Program specifies certain numbered version GNU Affero General Public License “later version” applies , option following terms conditions either numbered version later version published Free Software Foundation. Program specify version number GNU Affero General Public License, may choose version ever published Free Software Foundation. Program specifies proxy can decide future versions GNU Affero General Public License can used, proxy’s public statement acceptance version permanently authorizes choose version Program. Later license versions may give additional different permissions. However, additional obligations imposed author copyright holder result choosing follow later version.","code":""},{"path":"https://davidrach.github.io/Coereba/LICENSE.html","id":"15-disclaimer-of-warranty","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"15. Disclaimer of Warranty.","title":"GNU Affero General Public License","text":"WARRANTY PROGRAM, EXTENT PERMITTED APPLICABLE LAW. EXCEPT OTHERWISE STATED WRITING COPYRIGHT HOLDERS /PARTIES PROVIDE PROGRAM “” WITHOUT WARRANTY KIND, EITHER EXPRESSED IMPLIED, INCLUDING, LIMITED , IMPLIED WARRANTIES MERCHANTABILITY FITNESS PARTICULAR PURPOSE. ENTIRE RISK QUALITY PERFORMANCE PROGRAM . PROGRAM PROVE DEFECTIVE, ASSUME COST NECESSARY SERVICING, REPAIR CORRECTION.","code":""},{"path":"https://davidrach.github.io/Coereba/LICENSE.html","id":"16-limitation-of-liability","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"16. Limitation of Liability.","title":"GNU Affero General Public License","text":"EVENT UNLESS REQUIRED APPLICABLE LAW AGREED WRITING COPYRIGHT HOLDER, PARTY MODIFIES /CONVEYS PROGRAM PERMITTED , LIABLE DAMAGES, INCLUDING GENERAL, SPECIAL, INCIDENTAL CONSEQUENTIAL DAMAGES ARISING USE INABILITY USE PROGRAM (INCLUDING LIMITED LOSS DATA DATA RENDERED INACCURATE LOSSES SUSTAINED THIRD PARTIES FAILURE PROGRAM OPERATE PROGRAMS), EVEN HOLDER PARTY ADVISED POSSIBILITY DAMAGES.","code":""},{"path":"https://davidrach.github.io/Coereba/LICENSE.html","id":"17-interpretation-of-sections-15-and-16","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"17. Interpretation of Sections 15 and 16.","title":"GNU Affero General Public License","text":"disclaimer warranty limitation liability provided given local legal effect according terms, reviewing courts shall apply local law closely approximates absolute waiver civil liability connection Program, unless warranty assumption liability accompanies copy Program return fee. END TERMS CONDITIONS","code":""},{"path":"https://davidrach.github.io/Coereba/LICENSE.html","id":"how-to-apply-these-terms-to-your-new-programs","dir":"","previous_headings":"","what":"How to Apply These Terms to Your New Programs","title":"GNU Affero General Public License","text":"develop new program, want greatest possible use public, best way achieve make free software everyone can redistribute change terms. , attach following notices program. safest attach start source file effectively state exclusion warranty; file least “copyright” line pointer full notice found. Also add information contact electronic paper mail. software can interact users remotely computer network, also make sure provides way users get source. example, program web application, interface display “Source” link leads users archive code. many ways offer source, different solutions better different programs; see section 13 specific requirements. also get employer (work programmer) school, , sign “copyright disclaimer” program, necessary. information , apply follow GNU AGPL, see https://www.gnu.org/licenses/.","code":"<one line to give the program's name and a brief idea of what it does.>     Copyright (C) <year>  <name of author>      This program is free software: you can redistribute it and/or modify     it under the terms of the GNU Affero General Public License as     published by the Free Software Foundation, either version 3 of the     License, or (at your option) any later version.      This program is distributed in the hope that it will be useful,     but WITHOUT ANY WARRANTY; without even the implied warranty of     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     GNU Affero General Public License for more details.      You should have received a copy of the GNU Affero General Public License     along with this program.  If not, see <https://www.gnu.org/licenses/>."},{"path":"https://davidrach.github.io/Coereba/articles/Workflow.html","id":"background","dir":"Articles","previous_headings":"","what":"Background","title":"Using Coereba","text":"Manual (supervised) analysis widespread cytometry (especially conventional flow cytometry (CFC)), wherein researchers draw hierarchial boolean gates around cell populations using graphical user interface provided various commercial softwares. sequentially switching markers, end filtering smaller subsets cells potential interest. increase markers (initially mass cytometry (MC), recently spectral flow cytometry (SFC)) accompanying combinatorial combinations needing gated, algorithmic (unsupervised) analysis methods developed cluster cells basis median fluorescent intensity (MFI) individual markers. handle combinatorial data, many identified clusters present (/biologically meaningful) remains point concern. additional dependence MFI values consistent across individuals experiments increases methods susceptibility batch effects.","code":""},{"path":"https://davidrach.github.io/Coereba/articles/Workflow.html","id":"rationale","dir":"Articles","previous_headings":"","what":"Rationale","title":"Using Coereba","text":"SFC datasets particular, collecting greater numbers cells MC increased number markers compared CFC, require new tools enable comprehensive profiling phenotypes present within acquired cells. datasets loss resolution due improper unmixing controls poses additional challenges. Coereba collection tools attempt implement semi-supervised analytical approach. Using automated gating, splitpoints positive negative cells every marker estimated individual basis. extensive visualization ShinyApp, failures gate setting algorithmic gating can adjusted researcher. Individual cells classified basis marker splitpoints, identity metadata information appended .fcs file. Following unsupervised analysis, manually defined gating information can extracted used analysis verify algorithm performed predicted across specimens. Due researcher intervention, resilient batch effects pure MFI approach. author maintainer part claims Coereba solution cytometry analysis woes. tool open-source toolbelt can enable useful things figure interesting quirks wouldn’t otherwise able . Go forth, gain better understanding underlying problems current paradigms , may next generation researchers benefit learn.","code":""},{"path":[]},{"path":"https://davidrach.github.io/Coereba/articles/Workflow.html","id":"installing-coereba","dir":"Articles","previous_headings":"Getting Started","what":"Installing Coereba","title":"Using Coereba","text":"Coereba R package preparation submission Bioconductor later year. time, available install via GitHub.","code":"if(!require(\"remotes\")) {install.packages(\"remotes\")} remotes::install_github(\"https://github.com/DavidRach/Coereba\")  # install.packages(\"BiocManager\") # BiocManager::install(\"Coereba\")"},{"path":"https://davidrach.github.io/Coereba/articles/Workflow.html","id":"loading-libraries","dir":"Articles","previous_headings":"Getting Started","what":"Loading Libraries","title":"Using Coereba","text":"Coereba relies underlying infrastructure provided flowWorkspace Bioconductor cytometry packages. leverages functional programming principles implemented tidyverse packages available via CRAN. important make sure required packages installed computer, library called .","code":"library(Coereba) library(flowCore) library(flowWorkspace) library(openCyto) library(ggcyto)   library(data.table) library(dplyr) library(purrr)  library(stringr) library(ggplot2) library(gt) library(plotly) library(htmltools)"},{"path":"https://davidrach.github.io/Coereba/articles/Workflow.html","id":"locating--fcs-files","dir":"Articles","previous_headings":"Getting Started > Loading Libraries","what":"Locating .fcs files","title":"Using Coereba","text":"get started, first need provide location computer .fcs files interest stored. example author provided can modified user desired computer folder. vignette, using several small .fcs files can found Coereba’s extdata folder example. folder contains three unmixed full-stained samples 29-color SFC panel, characterizing Innate-like T cells (ILT) cord blood mononuclear cells (CBMCs). rare circulating cells, original .fcs files contained many cellular events, makes useful show Coereba’s capabilities characterizing cells original focus.","code":"File_Location <- file.path(\"C:\", \"Users\", \"JohnDoe\", \"Desktop\", \"TodaysExperiment\") FCS_Pattern <- \".fcs$\" FCS_Files <- list.files(path = File_Location, pattern = FCS_Pattern,                         full.names = TRUE, recursive = FALSE) File_Location <- system.file(\"extdata\", package = \"Coereba\") FCS_Pattern <- \".fcs$\" FCS_Files <- list.files(path = File_Location, pattern = FCS_Pattern,                         full.names = TRUE, recursive = FALSE) head(FCS_Files, 3)"},{"path":"https://davidrach.github.io/Coereba/articles/Workflow.html","id":"creating-a-gatingset-for-unmixed--fcs-files","dir":"Articles","previous_headings":"Getting Started > Loading Libraries","what":"Creating a GatingSet for Unmixed .fcs files","title":"Using Coereba","text":"Working unmixed full-stained samples mentioned , proceed bringing .fcs files found within Coereba’s extdata folder GatingSet object can interact . Now created GatingSet object, identify markers/fluorophores present within .fcs files, exclude markers list don’t require transformation (case FSC, SSC). bi-exponentially transform data using flowWorkspace flowWorkspace::flowjo_biexp_trans() applying openCytogating template customized particular panel, can found extdata folder. can additionally verify gating cell populations interest correct, visualizing gates using ggcyto Luciernaga package.","code":"UnmixedFCSFiles <- FCS_Files[c(1:2)] UnmixedCytoSet <- load_cytoset_from_fcs(UnmixedFCSFiles, truncate_max_range = FALSE,                                         transformation = FALSE) UnmixedGatingSet <- GatingSet(UnmixedCytoSet) UnmixedGatingSet Markers <- colnames(UnmixedCytoSet) KeptMarkers <- Markers[-grep(\"Time|FS|SC|SS|Original|-W$|-H$|AF\", Markers)]  MyBiexponentialTransform <- flowjo_biexp_trans(channelRange = 256, maxValue = 1000000,                                                pos = 4.5, neg = 0, widthBasis = -1000) TransformList <- transformerList(KeptMarkers, MyBiexponentialTransform) UnmixedGatingSet <- transform(UnmixedGatingSet, TransformList)  UnmixedGates <- fread(file.path(path = File_Location, pattern = 'GatesUnmixed.csv')) UnmixedGating <- gatingTemplate(UnmixedGates) gt_gating(UnmixedGating, UnmixedGatingSet) plot(UnmixedGatingSet) library(Luciernaga)  MyPlot <- Utility_GatingPlots(x=UnmixedGatingSet[1], sample.name=c(\"GROUPNAME\", \"TUBENAME\"),                               removestrings=\".fcs\", subset=\"live\", gtFile=UnmixedGates,                               DesiredGates=NULL, outpath = getwd(), export=FALSE,                               therows=3, thecolumns=2)  MyPlot"},{"path":"https://davidrach.github.io/Coereba/articles/Workflow.html","id":"coereba_gatecutoffs","dir":"Articles","previous_headings":"","what":"Coereba_GateCutoffs","title":"Using Coereba","text":"set GatingSet transformations gates applied, can proceed test Coereba workflow. first step create .csv file, containing individual specimens, individual markers interest. cell within .csv file correspond MFI given marker given individual positive expression marker transitions becoming negative (referred splitpoint). written individually, based automated calculations. simplify process, Coereba, implemented two approaches estimating splitpoints. One function -house Coereba_GateCutoffs(), “okay-ish work-progress”. flip approach leveraging openCyto pipeline (development) retrieving values. approaches can computationally heavy, still faster eye-balling everything typing values one--one. Save eyestrain subsequent validation steps.","code":"TheGateCutoff <- Coereba_GateCutoffs(gs=UnmixedGatingSet[1],   subset=\"live\", sample.name=\"GROUPNAME\", desiredCols =c(\"BUV805-A\"))  TheGateCutoffs <- map(.x=UnmixedGatingSet[1:3], .f=Coereba_GateCutoffs,   subset=\"live\", sample.name=\"GROUPNAME\", desiredCols =c(\"BUV805-A\")) %>% bind_rows() TheGateCutoffs"},{"path":"https://davidrach.github.io/Coereba/articles/Workflow.html","id":"visualizing-gate-cutoffs","dir":"Articles","previous_headings":"","what":"Visualizing Gate Cutoffs","title":"Using Coereba","text":"generated GateCutoffs.csv file, can visualize well splitpoints plotting red-lines using Luciernaga packages Utility_NbyNPlots() visualize markers given individual Utility_UnityPlots() visualize markers across individuals. good way understanding well competing gating-algorithms context individual panel, much effort required next step correcting gates individually.","code":""},{"path":"https://davidrach.github.io/Coereba/articles/Workflow.html","id":"coereba_app","dir":"Articles","previous_headings":"","what":"Coereba_App","title":"Using Coereba","text":"Previously, adjustments splitpoints eye-balled pdf, adjusted .csv file, repeated ad nauseum. obviously scale well. subsequently created ShinyApp bring GatingSet object, plot interactive version Utility_UnityPlot() Luciernaga package, visualizing splitpoint given marker across individuals red vertical lines. get started, first make sure know Coereba_GateCutoffs() .csv output saved , need select file within App. Next, make sure remember name GatingSet (“UnmixedGatingSet” case), sample.name keyword identify individual specimens, need input values within app. , run following command console: first tab view let upload GateCutoff.csv file generated previous function, letting navigate storage folder clicking . done, navigate Upload GatingSet tab. Enter information GatingSet (“UnmixedGatingSet” example), select x y parameters, enter SampleName keyword. Desired bins allows adjustments visualization given number cells present, clearance multiplier adjust margins wiggle-room, removestrings arguments. specify margin gate subsets like Utility_UnityPlots() click Display Estimated Gate Cutoffs. Finally, click Generate Plots go retrieve coffee/tea/beverage--choice. Upon loading plots, scroll encounter splitpoint line placed incorrectly, can simply click correct location axis, save coordinate splitpoint given marker individual data.frame. later ported update corresponding splitpoint value given marker individual exisiting GateCutoff .csv. just clicking, can therefore quickly correct cases algorithm failed gate properly due batch effects, bad staining, algorithmic incompetence (sorry, coders still learning well). corrected /markers, navigate Click Data tab. can export click-data information specifying filename providing outpath folder want save . Unfortunately, due security issues ShinyApps, need type designated outpath manually. repeat markers interested validated folder clickpoint .csvs awaiting conversion existing GateCutoff folder. Since code within ShinyApp running R, advantages disadvantages R Shiny App. scales reasonably well, can take load next iterated marker. testing, loading new marker inspect took anywhere 3-10 additional minutes. area active work progress speed , author/maintainer hasn’t time finish reading Mastering Shiny Hadley Wickham yet implement Rust, , feel free assist!","code":"File_Location <- system.file(\"extdata\", package = \"Coereba\") TheCSV <- file.path(File_Location, \"GateCutoffsForNKs.csv\") TheCSVData <- read.csv(TheCSV, check.names=FALSE) head(TheCSVData) Coereba_App()"},{"path":"https://davidrach.github.io/Coereba/articles/Workflow.html","id":"coereba_updategates","dir":"Articles","previous_headings":"","what":"Coereba_UpdateGates","title":"Using Coereba","text":"completed validating GateCutoffs Coereba_App(), time convert validated click-data update GateCutoff.csv. fascilitate , provide location folder containing just clickpoint .csv’s Coereba_UpdateGates() fill required arguments. proceed update GateCutoffs. example, use ClickDataExamples.csv stored within Coereba’s extdata folder: old data: can run Coereba_UpdateGates() watch values BUV469-updated. can validate re-running Luciernaga Utility_UnityPlots() using updated GateCutoff.csv seeing previous issues corrected.","code":"File_Location <- system.file(\"extdata\", package = \"Coereba\") TheOldCSV <- file.path(File_Location, \"GateCutoffsForNKs.csv\") TheClickInfo <- file.path(File_Location, \"ClickDataExample.csv\") TheClickData <- read.csv(TheClickInfo, check.names=FALSE) TheClickData TheOldData <- read.csv(TheOldCSV, check.names=FALSE) TheOldData UpdatedCSV <- Coereba_UpdateGates(Clicks=TheClickInfo, Old=TheOldCSV,   export=FALSE, outpath=NULL, fileName=\"UpdatedCSV\")  UpdatedCSV"},{"path":"https://davidrach.github.io/Coereba/articles/Workflow.html","id":"note-on-cell-populations-and-splitpoint","dir":"Articles","previous_headings":"","what":"Note on Cell Populations and Splitpoint","title":"Using Coereba","text":"development, noticed SFC data, splitpoint location can vary substantially individual cell populations (B cells, NK cells, T cells, etc), even abscence biology. believe due uncertainty unmixing, observed correlation negative splitpoint MFI relation individual cells kappa value (matrix complexity essentially). Try best gate reflect interested , reduce amount error much can, numbers veritas. Keep track exceptions (later) write Cyto paper.","code":""},{"path":"https://davidrach.github.io/Coereba/articles/Workflow.html","id":"how-coereba-works","dir":"Articles","previous_headings":"","what":"How Coereba works","title":"Using Coereba","text":"GateCutoff.csv containing splitpoint information marker validated individual immensely useful, allowing many things wouldn’t capable otherwise. Namely, can individual anotate cell within .fcs file. mean? Let’s first think cells circulating individuals bloostream. don’t prior information example, want profile cells clusters similar cells. one end spectra, single cluster contains every single cell sample, regardless marker expression. opposite end spectrum, every single cell clusters ’s cluster just . two extremes, depending question, lies meaningful cluster number match underlying biology reduce amount variance lies clumping/splitting populations needlessly. Coereba takes approacch individually annotating individuals cells one one, basis MFI value lands related validated splitpoint. splitpoint FITC 50, individual cell MFI FITC 80, returns FITC_pos. splitpoint APC 70, individual cell MFI 30, returns APC_Neg. iterate splitpoints marker, cell derrives identity. FITC_pos-APC_Neg-BV421_Pos…. etc. can group cells matching identies derrive information terminal nodes. Individually, may mean much. , dichotomous splitting 30-marker panel around half-billion potential terminal nodes clusters. Similarly, cytometers instrumental, batch, experimental noise, etc. scale events collected within typical sample, get far fewer terminal nodes, hundred lower thousand range 30-color panel. reason cells (panels investigate ) uniformely distributed markers across high-dimensional space, cells fall within specific phenotypes (cell types) undergo division similar clones. Consequently, can iteratively leverage number markers included target questions interest, broad narrow scope, context individual panels, rely methods described gain insight biological systems.","code":""},{"path":"https://davidrach.github.io/Coereba/articles/Workflow.html","id":"utility_coereba","dir":"Articles","previous_headings":"","what":"Utility_Coereba","title":"Using Coereba","text":"Utility_Coereba() function implements approach, labelling individual specimen individual cells basis splitpoint identity, returning enumeration resulting clusters. iterates different specimens GatingSet, returning information every individual can used subsequent steps. MultiReach() older version proccess. functions currently waiting ILT paper sent collaborators David can implement 5-subject binder worth notes implement S4 OOP class make manipulating final outputs easier current .qmd files full tidyverse data tidying.","code":"CoerebaIDs <- Utility_Coereba(x=UnmixedGatingSet[1], subsets=\"live\",   sample.name=\"GROUPNAME\", reference=TheCSV, starter=\"Spark Blue 550-A\") head(CoerebaIDs, 5)"},{"path":"https://davidrach.github.io/Coereba/articles/Workflow.html","id":"filtering-coereba-clusters","dir":"Articles","previous_headings":"","what":"Filtering Coereba Clusters","title":"Using Coereba","text":"things literally poisson noise. Others cell clusters varying abundance across heteregenous human patients. Others individually unique terminal nodes can result individual biology…. unmixing errors … lab tech messing staining panel. can leverage filter functions identify quickly.","code":""},{"path":"https://davidrach.github.io/Coereba/articles/Workflow.html","id":"coereba_markerexpressions","dir":"Articles","previous_headings":"","what":"Coereba_MarkerExpressions","title":"Using Coereba","text":"generated Marker Cluster data.frame (binaryData) Cluster Specimen data.frame (dataData), can leverage combination two data.frames aggregate clusters basis marker presence, returning proportion cells positive given marker. demonstration, focus NKTs, using stored .csv files binary data outputs stored within Coereba extdata folder. first just return marker expressions markers: can additionally specifying returnType = “Combinatorial” derrive proportions within quadrant gates two markers interest. , specify fluorophores corresponding markers list CombinatorialArgs.","code":"File_Location <- system.file(\"extdata\", package = \"Coereba\")  panelPath <- file.path(File_Location, \"ILTPanelTetramer.csv\") panelData <- read.csv(panelPath, check.names=FALSE)  binaryPath <- file.path(File_Location, \"HeatmapExample.csv\") binaryData <- read.csv(binaryPath, check.names=FALSE)  dataPath <- file.path(File_Location, \"ReadyFileExample.csv\") dataData <- read.csv(dataPath, check.names=FALSE) library(Coereba)  AllMarkers <- Coereba_MarkerExpressions(data=dataData, binary=binaryData,   panel=panelData, starter=\"SparkBlue550\")    head(AllMarkers, 5) MemoryQuadrants <- Coereba_MarkerExpressions(data=dataData, binary=binaryData,   panel=panelData, starter=\"SparkBlue550\", returnType = \"Combinatorial\",    CombinatorialArgs = c(\"BV510\", \"BUV395\"))  head(MemoryQuadrants, 5)"},{"path":"https://davidrach.github.io/Coereba/articles/Workflow.html","id":"utility_markerplots","dir":"Articles","previous_headings":"","what":"Utility_MarkerPlots","title":"Using Coereba","text":"returned aggregated data Coereba_MarkerExpressions, can plot data using Utility_MarkerPlots(). combination ggplot2 geom_boxplot() ggbeeswarm geom_beeswarm plots. provide arguments allow filtering reordering markers shown plots, basic customizations plots, ability save .png file designated folder. individual spots, need specify metadata column factor , provide list shape fill values corresponding factor level. can start viewing markers: Let’s abbreviate number columns specifying marker names include (filterForThese), rearrange desired X-axis order ggsave directly desired folder:","code":"shape_ptype <- c(\"HU\" = 22, \"HEU-lo\" = 21, \"HEU-hi\" = 21) fill_ptype <- c(\"HU\" = \"white\", \"HEU-lo\" = \"darkgray\", \"HEU-hi\" = \"black\") ThePlot <- Utility_MarkerPlots(data=AllMarkers, panel=panelData,   myfactor=\"ptype\", shape_palette = shape_ptype, fill_palette = fill_ptype)  ThePlot ThePlot <- Utility_MarkerPlots(data=AllMarkers, panel=panelData,   myfactor=\"ptype\", shape_palette = shape_ptype, fill_palette = fill_ptype,   filterForThese=c(\"CD7\", \"CD4\", \"CD8\"), XAxisLevels = c(\"CD7\", \"CD4\", \"CD8\"))  ThePlot"},{"path":"https://davidrach.github.io/Coereba/articles/Workflow.html","id":"utility_stats","dir":"Articles","previous_headings":"","what":"Utility_Stats","title":"Using Coereba","text":"Utility_Stats() Utility_Behemoth() functions either: “Great!!!”, guaranteed make friendly-local statistician cry (Opinions vary). Basically, Utility_Stats() coding-attempt replicate typical immunologist workflow, cutting need copy-paste data .csv file GraphPad Prism (trademark), run normality test, determine number groups, follow corresponding t-test/anova/non-parametric equivalents. Utility_Behemoth() takes outputs, adds p-value results ggbeeswarm/ggplot2 boxplot underlying data. combination purrr Luciernaga Utility_Patchwork(), can quickly formatted .pdf. workflow rapidly profile columns data.frame. Yes . emblematic potential issues arising basing science entirely null-hypothesis statistical testing? Also yes, seeing many plots return “significant” due couple outliers. end, mimics current workflow many researchers, just speeding . Google Statistical Rethinking YouTube food--thought. begin, use Coereba_MarkerExpressions data generated test Utility_Stats(). combination purrr can rapidly iterate markers, need skip metadata columns present begining dataframe. results can filtered using regular dplyr functions.","code":"Result <- Utility_Stats(data=AllMarkers, var=\"CD62L\",   myfactor=\"ptype\", normality=\"dagostino\", correction=\"none\")  Result library(purrr) library(dplyr) # colnames(AllMarkers) TheLength <- ncol(AllMarkers)  TheData <- map(names(AllMarkers)[c(9:TheLength)], ~ Utility_Stats(   data = AllMarkers, var = .x, myfactor = \"ptype\",    normality = \"dagostino\")) %>% bind_rows() MaybeSignificant <- TheData %>% dplyr::filter(pvalue < 0.05)  MaybeSignificant"},{"path":"https://davidrach.github.io/Coereba/articles/Workflow.html","id":"utility_behemoth","dir":"Articles","previous_headings":"","what":"Utility_Behemoth","title":"Using Coereba","text":"Utility_Behemoth() continues Utility_Stats() left-, appending resulting p-value information onto ggplot2 plot. plot combination ggplot2 geom_boxplot() ggbeeswarm geom_beeswarm plots, accepts arguments customize rearrange group order. Coereba plots, need provide shape fill respective factors levels. individual spots, need specify metadata column factor , provide list shape fill values corresponding factor level. combination purrr can rapidly iterate markers (skipping initial metadata colums) generate plots. can passed Luciernaga Utility_Patchwork() rearrange patchwork objects desired layout, passed .pdf file. turn can passed Luciernaga `Utility_Patchwork() function arrange desired layout output .pdf file late reference.","code":"shape_ptype <- c(\"HU\" = 22, \"HEU-lo\" = 21, \"HEU-hi\" = 21) fill_ptype <- c(\"HU\" = \"white\", \"HEU-lo\" = \"darkgray\", \"HEU-hi\" = \"black\") SinglePlot <- Utility_Behemoth(data=AllMarkers, var=\"CD62L\",   myfactor=\"ptype\", normality=\"dagostino\", correction=\"none\",   shape_palette=shape_ptype, fill_palette=fill_ptype,   XAxisLevels = c(\"HU\", \"HEU-lo\", \"HEU-hi\")) SinglePlot # colnames(AllMarkers) TheLength <- length(AllMarkers)  AllPlots <- map(names(AllMarkers)[c(9:TheLength)], ~ Utility_Behemoth(data=AllMarkers, var=.x,   myfactor=\"ptype\", normality=\"dagostino\", correction=\"none\",   shape_palette=shape_ptype, fill_palette=fill_ptype, corral.width=0.7,   XAxisLevels = c(\"HU\", \"HEU-lo\", \"HEU-hi\"))) library(Luciernaga)  StorageLocation <- file.path(\"C:\", \"Users\", \"JohnDoe\", \"Desktop\")  TheAssembledPlot <- Utility_Patchwork(x=AllPlots, filename=\"NKT_Markers\",  outfolder=NULL, thecolumns=2, therows=3, width=7, height=9,  returntype=\"patchwork\") TheAssembledPlot[1]"},{"path":"https://davidrach.github.io/Coereba/articles/Workflow.html","id":"utility_heatmap","dir":"Articles","previous_headings":"","what":"Utility_Heatmap","title":"Using Coereba","text":"original visualization Coereba clusters, Bananaquit color-scheme. Next time someone insist just 5 clusters FlowSOM, point .","code":"ThePlot <- Utility_Heatmap(binary=binaryData, panel=panelPath,   export=FALSE, outpath=NULL, filename=NULL) ThePlot"},{"path":"https://davidrach.github.io/Coereba/articles/Workflow.html","id":"diffcyt-port","dir":"Articles","previous_headings":"","what":"Diffcyt port","title":"Using Coereba","text":"Wrote function send outputs diffcyt edgeR/limma/GLMM modeling results (vs t-test approach). works, mean ’s less p-hacky? TBD. Also, given diffcyt’s current maintenance status (looking Luke), may best approach vs new implementation.","code":""},{"path":"https://davidrach.github.io/Coereba/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"David Rach. Author, maintainer.","code":""},{"path":"https://davidrach.github.io/Coereba/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Rach D (2024). Coereba: Dichotomized Boolean Clustering Heatmaps Spectral Flow Cytometry. R package version 0.1.0, https://github.com/DavidRach/Coereba.","code":"@Manual{,   title = {Coereba: Dichotomized Boolean Clustering and Heatmaps for Spectral Flow Cytometry},   author = {David Rach},   year = {2024},   note = {R package version 0.1.0},   url = {https://github.com/DavidRach/Coereba}, }"},{"path":[]},{"path":"https://davidrach.github.io/Coereba/index.html","id":"coereba-dichotomized-clustering-for-spectral-flow-cytometry","dir":"","previous_headings":"","what":"Coereba: Dichotomized Clustering for Spectral Flow Cytometry","title":"Dichotomized Clustering for Spectral Flow Cytometry (SFC)","text":"Coereba collection tools allowing researchers extend understanding panels datasets.","code":""},{"path":"https://davidrach.github.io/Coereba/index.html","id":"installation","dir":"","previous_headings":"Coereba: Dichotomized Clustering for Spectral Flow Cytometry","what":"Installation","title":"Dichotomized Clustering for Spectral Flow Cytometry (SFC)","text":"process getting Coereba ready submit Bioconductor. , please download package github.","code":"if(!require(\"remotes\")) install.packages(\"remotes\")  remotes::install_github(\"https://github.com/DavidRach/Coereba\")  library(Coereba)  # install.packages(\"BiocManager\") # BiocManager::install(\"Coereba\")"},{"path":"https://davidrach.github.io/Coereba/index.html","id":"get-started","dir":"","previous_headings":"Coereba: Dichotomized Clustering for Spectral Flow Cytometry","what":"Get Started","title":"Dichotomized Clustering for Spectral Flow Cytometry (SFC)","text":"Please check -vignettes get started","code":""},{"path":"https://davidrach.github.io/Coereba/index.html","id":"found-a-bug-report-it","dir":"","previous_headings":"Coereba: Dichotomized Clustering for Spectral Flow Cytometry","what":"Found a bug? Report it!","title":"Dichotomized Clustering for Spectral Flow Cytometry (SFC)","text":"caught lot bugs, ’s still unknown ones haven’t encountered. find suspected bug, please report ","code":""},{"path":"https://davidrach.github.io/Coereba/reference/Coereba-package.html","id":null,"dir":"Reference","previous_headings":"","what":"Coereba: Dichotomized Clustering for Spectral Flow Cytometry (SFC) — Coereba-package","title":"Coereba: Dichotomized Clustering for Spectral Flow Cytometry (SFC) — Coereba-package","text":"learn use Coereba, please start browsing vignettes:","code":""},{"path":[]},{"path":"https://davidrach.github.io/Coereba/reference/Coereba-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Coereba: Dichotomized Clustering for Spectral Flow Cytometry (SFC) — Coereba-package","text":"Maintainer: David Rach drach@som.umaryland.edu (ORCID)","code":""},{"path":"https://davidrach.github.io/Coereba/reference/Coereba_App.html","id":null,"dir":"Reference","previous_headings":"","what":"Deploy a Shiny app to modify the estimated gate cutoff placement. — Coereba_App","title":"Deploy a Shiny app to modify the estimated gate cutoff placement. — Coereba_App","text":"Deploy Shiny app modify estimated gate cutoff placement.","code":""},{"path":"https://davidrach.github.io/Coereba/reference/Coereba_App.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Deploy a Shiny app to modify the estimated gate cutoff placement. — Coereba_App","text":"","code":"Coereba_App()"},{"path":"https://davidrach.github.io/Coereba/reference/Coereba_App.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Deploy a Shiny app to modify the estimated gate cutoff placement. — Coereba_App","text":"Launches Shiny app","code":""},{"path":"https://davidrach.github.io/Coereba/reference/Coereba_App.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Deploy a Shiny app to modify the estimated gate cutoff placement. — Coereba_App","text":"","code":"library(flowCore) library(flowWorkspace) #> As part of improvements to flowWorkspace, some behavior of #> GatingSet objects has changed. For details, please read the section #> titled \"The cytoframe and cytoset classes\" in the package vignette: #>  #>   vignette(\"flowWorkspace-Introduction\", \"flowWorkspace\") library(openCyto) library(data.table)  File_Location <- system.file(\"extdata\", package = \"Coereba\") TheCSV <- file.path(File_Location, \"GateCutoffsForNKs.csv\")  FCS_Files <- list.files(path = File_Location, pattern = \".fcs\", full.names = TRUE) UnmixedFCSFiles <- FCS_Files[1] UnmixedCytoSet <- load_cytoset_from_fcs(UnmixedFCSFiles,  truncate_max_range = FALSE, transformation = FALSE) UnmixedGatingSet <- GatingSet(UnmixedCytoSet) Markers <- colnames(UnmixedCytoSet) KeptMarkers <- Markers[-grep(\"Time|FS|SC|SS|Original|-W$|-H$|AF\", Markers)] biex_transform <- flowjo_biexp_trans(channelRange = 256, maxValue = 1000000,  pos = 4.5, neg = 0, widthBasis = -1000) TransformList <- transformerList(KeptMarkers, biex_transform) flowWorkspace::transform(UnmixedGatingSet, TransformList) #> A GatingSet with 1 samples UnmixedGates <- fread(file.path(path = File_Location,  pattern = 'GatesUnmixed.csv')) UnmixedGating <- gatingTemplate(UnmixedGates) #> Adding population:singletsFSC #> Adding population:singletsSSC #> Adding population:singletsSSCB #> Adding population:nonDebris #> Adding population:lymphocytes #> Adding population:live gt_gating(UnmixedGating, UnmixedGatingSet) #> Gating for 'singletsFSC' #> done! #> done. #> Gating for 'singletsSSC' #> done! #> done. #> Gating for 'singletsSSCB' #> done! #> done. #> Gating for 'nonDebris' #> done! #> done. #> Gating for 'lymphocytes' #> The prior specification has no effect when usePrior=no #> Using the serial version of flowClust #> done! #> done. #> Gating for 'live' #> done! #> done. #> finished.  # Coereba_App()"},{"path":"https://davidrach.github.io/Coereba/reference/Coereba_Comparison.html","id":null,"dir":"Reference","previous_headings":"","what":"Compares two Coereba populations to find difference, returning either data or a plot of the marker expressions — Coereba_Comparison","title":"Compares two Coereba populations to find difference, returning either data or a plot of the marker expressions — Coereba_Comparison","text":"Compares two Coereba populations find difference, returning either data plot marker expressions","code":""},{"path":"https://davidrach.github.io/Coereba/reference/Coereba_Comparison.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compares two Coereba populations to find difference, returning either data or a plot of the marker expressions — Coereba_Comparison","text":"","code":"Coereba_Comparison(gs, gs2 = NULL, Arg1, Arg2, panel, returnType)"},{"path":"https://davidrach.github.io/Coereba/reference/Coereba_Comparison.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compares two Coereba populations to find difference, returning either data or a plot of the marker expressions — Coereba_Comparison","text":"gs GatingSet gs2 Default NULL, comparing different GatingSet Arg1 First Population Name Arg2 Second Population Name, can identical different GatingSet panel data.frame file.path Panel .csv returnType Whether return \"plot\" \"data\". Data default.","code":""},{"path":"https://davidrach.github.io/Coereba/reference/Coereba_Comparison.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compares two Coereba populations to find difference, returning either data or a plot of the marker expressions — Coereba_Comparison","text":"Either data ggplot2 object comparing two populations interest","code":""},{"path":"https://davidrach.github.io/Coereba/reference/Coereba_Comparison.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compares two Coereba populations to find difference, returning either data or a plot of the marker expressions — Coereba_Comparison","text":"","code":"library(Coereba)"},{"path":"https://davidrach.github.io/Coereba/reference/Coereba_GateCutoffs.html","id":null,"dir":"Reference","previous_headings":"","what":"Function to guess the gate cutoff values — Coereba_GateCutoffs","title":"Function to guess the gate cutoff values — Coereba_GateCutoffs","text":"Function guess gate cutoff values","code":""},{"path":"https://davidrach.github.io/Coereba/reference/Coereba_GateCutoffs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function to guess the gate cutoff values — Coereba_GateCutoffs","text":"","code":"Coereba_GateCutoffs(   gs,   subset,   sample.name,   desiredCols = NULL,   returnTemplate = FALSE,   outpath = NULL,   GatingTemplate = NULL,   returnPlots = FALSE,   InternalCheck = FALSE )"},{"path":"https://davidrach.github.io/Coereba/reference/Coereba_GateCutoffs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function to guess the gate cutoff values — Coereba_GateCutoffs","text":"gs GatingSet object subset Gate node interest sample.name keyword specimens name stored desiredCols Column names fluorophores want gate returnTemplate Default FALSE, set TRUE returns .csv Gating Template can modified provisioned GatingTemplate argument outpath Default NULL, provides file path desired folder store returnTemplate GatingTemplate file.path GatingTemplate .csv want swap returnPlots Development, TRUE Internal Check TRUE, returns troubleshooting plots InternalCheck Development, default FALSE","code":""},{"path":"https://davidrach.github.io/Coereba/reference/Coereba_GateCutoffs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Function to guess the gate cutoff values — Coereba_GateCutoffs","text":"data.frame estimated gate cutoffs every marker  every specimen","code":""},{"path":"https://davidrach.github.io/Coereba/reference/Coereba_GateCutoffs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Function to guess the gate cutoff values — Coereba_GateCutoffs","text":"","code":"library(flowCore) library(flowWorkspace) library(openCyto) library(data.table)  File_Location <- system.file(\"extdata\", package = \"Coereba\") FCS_Files <- list.files(path = File_Location, pattern = \".fcs\", full.names = TRUE) UnmixedFCSFiles <- FCS_Files[1] UnmixedCytoSet <- load_cytoset_from_fcs(UnmixedFCSFiles,  truncate_max_range = FALSE, transformation = FALSE) UnmixedGatingSet <- GatingSet(UnmixedCytoSet) Markers <- colnames(UnmixedCytoSet) KeptMarkers <- Markers[-grep(\"Time|FS|SC|SS|Original|-W$|-H$|AF\", Markers)] biex_transform <- flowjo_biexp_trans(channelRange = 256, maxValue = 1000000,  pos = 4.5, neg = 0, widthBasis = -1000) TransformList <- transformerList(KeptMarkers, biex_transform) flowWorkspace::transform(UnmixedGatingSet, TransformList) #> A GatingSet with 1 samples UnmixedGates <- fread(file.path(path = File_Location,  pattern = 'GatesUnmixed.csv')) UnmixedGating <- gatingTemplate(UnmixedGates) #> Adding population:singletsFSC #> Adding population:singletsSSC #> Adding population:singletsSSCB #> Adding population:nonDebris #> Adding population:lymphocytes #> Adding population:live gt_gating(UnmixedGating, UnmixedGatingSet) #> Gating for 'singletsFSC' #> done! #> done. #> Gating for 'singletsSSC' #> done! #> done. #> Gating for 'singletsSSCB' #> done! #> done. #> Gating for 'nonDebris' #> done! #> done. #> Gating for 'lymphocytes' #> The prior specification has no effect when usePrior=no #> Using the serial version of flowClust #> done! #> done. #> Gating for 'live' #> done! #> done. #> finished.  TheGateCutoffs <- Coereba_GateCutoffs(gs=UnmixedGatingSet[1],  subset=\"live\", sample.name=\"GROUPNAME\")"},{"path":"https://davidrach.github.io/Coereba/reference/Coereba_MarkerExpressions.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate overall marker expressions across Coereba clusters, — Coereba_MarkerExpressions","title":"Generate overall marker expressions across Coereba clusters, — Coereba_MarkerExpressions","text":"Generate overall marker expressions across Coereba clusters,","code":""},{"path":"https://davidrach.github.io/Coereba/reference/Coereba_MarkerExpressions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate overall marker expressions across Coereba clusters, — Coereba_MarkerExpressions","text":"","code":"Coereba_MarkerExpressions(   data,   binary,   panel,   starter,   returnType = \"All\",   CombinatorialArgs = NULL )"},{"path":"https://davidrach.github.io/Coereba/reference/Coereba_MarkerExpressions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate overall marker expressions across Coereba clusters, — Coereba_MarkerExpressions","text":"data data.frame clusters vs individual specimens, ratio values binary data.frame markers vs clusters, 0 1 values panel .csv data.frame containing Fluorophore Marker columns panel markers. starter string containing starting characters Coereba cluster names returnType Either \"\" \"Combinatorial\". Default . CombinatorialArgs returnType Combinatorial, two fluorophores create quadrants .","code":""},{"path":"https://davidrach.github.io/Coereba/reference/Coereba_MarkerExpressions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate overall marker expressions across Coereba clusters, — Coereba_MarkerExpressions","text":"returns data.frame","code":""},{"path":"https://davidrach.github.io/Coereba/reference/Coereba_MarkerExpressions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate overall marker expressions across Coereba clusters, — Coereba_MarkerExpressions","text":"","code":"File_Location <- system.file(\"extdata\", package = \"Coereba\") panelPath <- file.path(File_Location, \"ILTPanelTetramer.csv\") panelData <- read.csv(panelPath, check.names=FALSE) binaryPath <- file.path(File_Location, \"HeatmapExample.csv\") binaryData <- read.csv(binaryPath, check.names=FALSE) dataPath <- file.path(File_Location, \"ReadyFileExample.csv\") dataData <- read.csv(dataPath, check.names=FALSE)  All <- Coereba_MarkerExpressions(data=dataData, binary=binaryData,  panel=panelData, starter=\"SparkBlue550\")  Memory <- Coereba_MarkerExpressions(data=dataData, binary=binaryData,  panel=panelData, starter=\"SparkBlue550\", returnType = \"Combinatorial\",  CombinatorialArgs=c(\"BV510\", \"APC-Fire 750\"))"},{"path":"https://davidrach.github.io/Coereba/reference/Coereba_MarkerExpressions2.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate overall marker expressions across Coereba clusters, — Coereba_MarkerExpressions2","title":"Generate overall marker expressions across Coereba clusters, — Coereba_MarkerExpressions2","text":"Generate overall marker expressions across Coereba clusters,","code":""},{"path":"https://davidrach.github.io/Coereba/reference/Coereba_MarkerExpressions2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate overall marker expressions across Coereba clusters, — Coereba_MarkerExpressions2","text":"","code":"Coereba_MarkerExpressions2(   x,   theassay = \"ratios\",   returnType = \"All\",   CombinatorialArgs = NULL )"},{"path":"https://davidrach.github.io/Coereba/reference/Coereba_MarkerExpressions2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate overall marker expressions across Coereba clusters, — Coereba_MarkerExpressions2","text":"x Coereba Summarized Experiment object Coereba_Processing returnType Either \"\" \"Combinatorial\". Default . CombinatorialArgs returnType Combinatorial, two fluorophores create quadrants . TheAssay Default \"ratios\"","code":""},{"path":"https://davidrach.github.io/Coereba/reference/Coereba_MarkerExpressions2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate overall marker expressions across Coereba clusters, — Coereba_MarkerExpressions2","text":"returns data.frame","code":""},{"path":"https://davidrach.github.io/Coereba/reference/Coereba_MarkerExpressions2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate overall marker expressions across Coereba clusters, — Coereba_MarkerExpressions2","text":"","code":"File_Location <- system.file(\"extdata\", package = \"Coereba\") panelPath <- file.path(File_Location, \"ILTPanelTetramer.csv\")  files <- gs_pop_get_data(gs, \"CD4\") #> Error: object 'gs' not found MySE <- Coereba_Processing(x=files[[1]], panel=panelPath) #> Error: object 'files' not found  All <- Coereba_MarkerExpressions2(x=MySE) #> Error in h(simpleError(msg, call)): error in evaluating the argument 'x' in selecting a method for function 'metadata': object 'MySE' not found  Memory <- Coereba_MarkerExpressions2(x=MySE, returnType = \"Combinatorial\",  CombinatorialArgs=c(\"BV510\", \"APC-Fire 750\")) #> Error in h(simpleError(msg, call)): error in evaluating the argument 'x' in selecting a method for function 'metadata': object 'MySE' not found"},{"path":"https://davidrach.github.io/Coereba/reference/Coereba_Processing.html","id":null,"dir":"Reference","previous_headings":"","what":"Takes Utility_Coereba output, plus additional metadata,and returns as a Bioconductor Summarized Experiment object — Coereba_Processing","title":"Takes Utility_Coereba output, plus additional metadata,and returns as a Bioconductor Summarized Experiment object — Coereba_Processing","text":"Takes Utility_Coereba output, plus additional metadata,returns  Bioconductor Summarized Experiment object","code":""},{"path":"https://davidrach.github.io/Coereba/reference/Coereba_Processing.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Takes Utility_Coereba output, plus additional metadata,and returns as a Bioconductor Summarized Experiment object — Coereba_Processing","text":"","code":"Coereba_Processing(   x,   metadata = NULL,   metadata_columns = NULL,   Identity = \"specimen\",   metadataTemplate = FALSE,   outpath = NULL,   panel )"},{"path":"https://davidrach.github.io/Coereba/reference/Coereba_Processing.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Takes Utility_Coereba output, plus additional metadata,and returns as a Bioconductor Summarized Experiment object — Coereba_Processing","text":"x object Coereba gating metadata. Acccepted arguments include  file.path .fcs, flowFrame cytoFrame, data.frame. metadata data.frame file.path metadata.csv file metadata_columns vector column names metadata want incorporate. Identity Column designating specimen metadata metadataTemplate metadata NULL, returns template data.frame containing specimen list. outpath Default NULL, alternate file.path send metadataTemplate output . panel data.frame file.path .csv containing Fluorophore Marker columns","code":""},{"path":"https://davidrach.github.io/Coereba/reference/Coereba_Processing.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Takes Utility_Coereba output, plus additional metadata,and returns as a Bioconductor Summarized Experiment object — Coereba_Processing","text":"summarized experiment object","code":""},{"path":"https://davidrach.github.io/Coereba/reference/Coereba_Processing.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Takes Utility_Coereba output, plus additional metadata,and returns as a Bioconductor Summarized Experiment object — Coereba_Processing","text":"","code":"library(Coereba)"},{"path":"https://davidrach.github.io/Coereba/reference/Coereba_UpdateGates.html","id":null,"dir":"Reference","previous_headings":"","what":"Update a gate cutoff csv with the Coereba_App edits — Coereba_UpdateGates","title":"Update a gate cutoff csv with the Coereba_App edits — Coereba_UpdateGates","text":"Update gate cutoff csv Coereba_App edits","code":""},{"path":"https://davidrach.github.io/Coereba/reference/Coereba_UpdateGates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Update a gate cutoff csv with the Coereba_App edits — Coereba_UpdateGates","text":"","code":"Coereba_UpdateGates(Clicks, Old, export = TRUE, outpath, fileName)"},{"path":"https://davidrach.github.io/Coereba/reference/Coereba_UpdateGates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Update a gate cutoff csv with the Coereba_App edits — Coereba_UpdateGates","text":"Clicks path .csv file folder containing Click .csv files. Old File path CSV containing original Estimated Gate Cutoffs export Whether export updated .csv, default TRUE outpath File path save new .csv file . fileName Desired name updated .csv file","code":""},{"path":"https://davidrach.github.io/Coereba/reference/Coereba_UpdateGates.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Update a gate cutoff csv with the Coereba_App edits — Coereba_UpdateGates","text":"updated .csv file new location, data.frame","code":""},{"path":"https://davidrach.github.io/Coereba/reference/Coereba_UpdateGates.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Update a gate cutoff csv with the Coereba_App edits — Coereba_UpdateGates","text":"","code":"File_Location <- system.file(\"extdata\", package = \"Coereba\") TheOldCSV <- file.path(File_Location, \"GateCutoffsForNKs.csv\") TheClickInfo <- file.path(File_Location, \"ClickDataExample.csv\")  UpdatedCSV <- Coereba_UpdateGates(Clicks=TheClickInfo, Old=TheOldCSV,  export=FALSE, outpath=NULL, fileName=\"UpdatedCSV\")"},{"path":"https://davidrach.github.io/Coereba/reference/Utility_Behemoth.html","id":null,"dir":"Reference","previous_headings":"","what":"From a data.frame, runs stats on column of interest, and returns the ggplot for it. — Utility_Behemoth","title":"From a data.frame, runs stats on column of interest, and returns the ggplot for it. — Utility_Behemoth","text":"data.frame, runs stats column interest, returns ggplot .","code":""},{"path":"https://davidrach.github.io/Coereba/reference/Utility_Behemoth.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"From a data.frame, runs stats on column of interest, and returns the ggplot for it. — Utility_Behemoth","text":"","code":"Utility_Behemoth(   data,   var,   myfactor,   normality = NULL,   specifiedNormality = NULL,   correction = \"none\",   override = 0.05,   shape_palette,   fill_palette,   cex = 2,   size = 3,   corral.width = 1,   XAxisLevels = NULL,   statLines = TRUE,   statsHeight = NULL,   showClose = TRUE,   scalePercent = FALSE,   keepNS = TRUE )"},{"path":"https://davidrach.github.io/Coereba/reference/Utility_Behemoth.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"From a data.frame, runs stats on column of interest, and returns the ggplot for it. — Utility_Behemoth","text":"data data.frame object metadata data columns var column name variable interest myfactor column name column containing factor group normality Normality test applied, \"dagostino\" \"shapiro\". Default NULL specifiedNormality Default NULL leading non-parametric, can switch specifying \"parametric\" \"nonparametric\". correction Multiple comparison correction argument, default set \"none\" override Internal, default 0.05. Set 0.99 force pairwise comparison anova/kw. shape_palette Palette corresponding factor levels, designating 's shape fill_palette Palette corresponding factor levels, designating 's fill cex width ggbeeswarm bin size Size ggbeeswarm circles. corral.width width corral bin argument beeswarm. XAxisLevels Provide list marker names correct order x-axis reordering, default NULL statLines Default TRUE, otherwise skips plotting pvalue brackets statsHeight Default NULL, provided, sets stat line y-axis height. showClose Default TRUE, displays pvalues 0.05 0.10 instead returning n.s scalePercent Default FALSE, scales 0 1 0-100 keepNS Default TRUE, false, removes ns plots.","code":""},{"path":"https://davidrach.github.io/Coereba/reference/Utility_Behemoth.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"From a data.frame, runs stats on column of interest, and returns the ggplot for it. — Utility_Behemoth","text":"ggplot2 object corresponding data interest.","code":""},{"path":"https://davidrach.github.io/Coereba/reference/Utility_Behemoth.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"From a data.frame, runs stats on column of interest, and returns the ggplot for it. — Utility_Behemoth","text":"","code":"shape_ptype <- c(\"HU\" = 22, \"HEU-lo\" = 21, \"HEU-hi\" = 21) fill_ptype <- c(\"HU\" = \"white\", \"HEU-lo\" = \"darkgray\", \"HEU-hi\" = \"black\")  File_Location <- system.file(\"extdata\", package = \"Coereba\") panelPath <- file.path(File_Location, \"ILTPanelTetramer.csv\") binaryPath <- file.path(File_Location, \"HeatmapExample.csv\") dataPath <- file.path(File_Location, \"ReadyFileExample.csv\") panelData <- read.csv(panelPath, check.names=FALSE) binaryData <- read.csv(binaryPath, check.names=FALSE) dataData <- read.csv(dataPath, check.names=FALSE)  All <- Coereba_MarkerExpressions(data=dataData, binary=binaryData,  panel=panelData, starter=\"SparkBlue550\")  Plot <- Utility_Behemoth(data=All, var=\"CD62L\", myfactor=\"ptype\",  normality=\"dagostino\", correction=\"none\", shape_palette=shape_ptype,  fill_palette=fill_ptype, XAxisLevels = c(\"HU\", \"HEU-lo\", \"HEU-hi\")) #> Error in if (at$p.value[1] < override) {    subset_data <- subset(data, select = c(var, myfactor))    ptt <- tidy(pairwise.t.test(subset_data[[var]], subset_data[[myfactor]],         p.adjust.method = correction))    ptt$method <- \"Pairwise t-test\"    ptt} else (at): missing value where TRUE/FALSE needed"},{"path":"https://davidrach.github.io/Coereba/reference/Utility_Coereba.html","id":null,"dir":"Reference","previous_headings":"","what":"Runs Coereba for Dichotomized Gating Annotation — Utility_Coereba","title":"Runs Coereba for Dichotomized Gating Annotation — Utility_Coereba","text":"Runs Coereba Dichotomized Gating Annotation","code":""},{"path":"https://davidrach.github.io/Coereba/reference/Utility_Coereba.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Runs Coereba for Dichotomized Gating Annotation — Utility_Coereba","text":"","code":"Utility_Coereba(   gs,   subsets,   sample.name,   subsample = NULL,   columns = NULL,   notcolumns = NULL,   reference,   starter,   inverse.transform = TRUE,   returnType,   Individual = FALSE,   outpath = NULL,   filename = NULL,   nameAppend = NULL )"},{"path":"https://davidrach.github.io/Coereba/reference/Utility_Coereba.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Runs Coereba for Dichotomized Gating Annotation — Utility_Coereba","text":"gs Gating Set object subsets desired GatingHierarchy subset sample.name Keyword sample name subsample optional downsample, work inverse.transform=TRUE columns optional way select columns keep. notcolumns optional way remove select columns. reference external data.frame path .csv specified gate split points specimen marker. starter column name start splits inverse.transform Whether reverse data transform Coereba cluster calculated, Default set TRUE allow .fcs export. returnType Whether return data, flowframe fcs Individual Default FALSE, TRUE, returns individual fcs instead grouped. outpath Default NULL, file.path fcs file storage filename Default NULL, sets name aggregated flowframe fcs nameAppend flowframe fcs returnType, gets appended .fcs","code":""},{"path":"https://davidrach.github.io/Coereba/reference/Utility_Coereba.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Runs Coereba for Dichotomized Gating Annotation — Utility_Coereba","text":"Either data, flowframe fcs, individually concatinated","code":""},{"path":"https://davidrach.github.io/Coereba/reference/Utility_Coereba.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Runs Coereba for Dichotomized Gating Annotation — Utility_Coereba","text":"","code":"library(flowCore) library(flowWorkspace) library(openCyto) library(data.table)  File_Location <- system.file(\"extdata\", package = \"Coereba\") TheCSV <- file.path(File_Location, \"GateCutoffsForNKs.csv\")  FCS_Files <- list.files(path = File_Location, pattern = \".fcs\", full.names = TRUE) UnmixedFCSFiles <- FCS_Files[1] UnmixedCytoSet <- load_cytoset_from_fcs(UnmixedFCSFiles,  truncate_max_range = FALSE, transformation = FALSE) UnmixedGatingSet <- GatingSet(UnmixedCytoSet) Markers <- colnames(UnmixedCytoSet[[1]]) KeptMarkers <- Markers[-grep(\"Time|FS|SC|SS|Original|-W$|-H$|AF\", Markers)] biex_transform <- flowjo_biexp_trans(channelRange = 256, maxValue = 1000000,  pos = 4.5, neg = 0, widthBasis = -1000) TransformList <- transformerList(KeptMarkers, biex_transform) flowWorkspace::transform(UnmixedGatingSet, TransformList) #> A GatingSet with 1 samples UnmixedGates <- fread(file.path(path = File_Location,  pattern = 'GatesUnmixed.csv')) UnmixedGating <- gatingTemplate(UnmixedGates) #> Adding population:singletsFSC #> Adding population:singletsSSC #> Adding population:singletsSSCB #> Adding population:nonDebris #> Adding population:lymphocytes #> Adding population:live gt_gating(UnmixedGating, UnmixedGatingSet) #> Gating for 'singletsFSC' #> done! #> done. #> Gating for 'singletsSSC' #> done! #> done. #> Gating for 'singletsSSCB' #> done! #> done. #> Gating for 'nonDebris' #> done! #> done. #> Gating for 'lymphocytes' #> The prior specification has no effect when usePrior=no #> Using the serial version of flowClust #> done! #> done. #> Gating for 'live' #> done! #> done. #> finished.  CoerebaIDs <- Utility_Coereba(gs=UnmixedGatingSet[1], subsets=\"live\",  sample.name=\"GROUPNAME\", reference=TheCSV, starter=\"Spark Blue 550-A\",  returnType=\"flowframe\", Individual=TRUE) #> sample.name does not match the specimen identifier name found in reference, #>      converting over #> returning individual flowframe"},{"path":"https://davidrach.github.io/Coereba/reference/Utility_Heatmap.html","id":null,"dir":"Reference","previous_headings":"","what":"Produces a Coereba Heatmap showing Coereba Clusters by Markers — Utility_Heatmap","title":"Produces a Coereba Heatmap showing Coereba Clusters by Markers — Utility_Heatmap","text":"Produces Coereba Heatmap showing Coereba Clusters Markers","code":""},{"path":"https://davidrach.github.io/Coereba/reference/Utility_Heatmap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Produces a Coereba Heatmap showing Coereba Clusters by Markers — Utility_Heatmap","text":"","code":"Utility_Heatmap(binary, panel, export = FALSE, outpath = NULL, filename = NULL)"},{"path":"https://davidrach.github.io/Coereba/reference/Utility_Heatmap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Produces a Coereba Heatmap showing Coereba Clusters by Markers — Utility_Heatmap","text":"binary data.frame markers cluster panel csv data.frame containing Fluorophore Marker export Whether export .png, default FALSE outpath File.path desired storage location filename File name exported image","code":""},{"path":"https://davidrach.github.io/Coereba/reference/Utility_Heatmap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Produces a Coereba Heatmap showing Coereba Clusters by Markers — Utility_Heatmap","text":"ggplot locally export location","code":""},{"path":"https://davidrach.github.io/Coereba/reference/Utility_Heatmap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Produces a Coereba Heatmap showing Coereba Clusters by Markers — Utility_Heatmap","text":"","code":"File_Location <- system.file(\"extdata\", package = \"Coereba\") panelPath <- file.path(File_Location, \"ILTPanelTetramer.csv\") panelData <- read.csv(panelPath, check.names=FALSE) binaryPath <- file.path(File_Location, \"HeatmapExample.csv\") binaryData <- read.csv(binaryPath, check.names=FALSE)  ThePlot <- Utility_Heatmap(binary=binaryData, panel=panelPath,  export=FALSE, outpath=NULL, filename=NULL)"},{"path":"https://davidrach.github.io/Coereba/reference/Utility_MarkerPlots.html","id":null,"dir":"Reference","previous_headings":"","what":"Takes Coereba_MarkerExpressions data.frame and returns Marker Expression Beeswarm plots — Utility_MarkerPlots","title":"Takes Coereba_MarkerExpressions data.frame and returns Marker Expression Beeswarm plots — Utility_MarkerPlots","text":"Takes Coereba_MarkerExpressions data.frame returns Marker Expression Beeswarm plots","code":""},{"path":"https://davidrach.github.io/Coereba/reference/Utility_MarkerPlots.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Takes Coereba_MarkerExpressions data.frame and returns Marker Expression Beeswarm plots — Utility_MarkerPlots","text":"","code":"Utility_MarkerPlots(   data,   panel,   myfactor,   shape_palette,   fill_palette,   cex = 1,   size = 1.5,   corral.width = 1,   crossbar = \"median\",   XAxisLevels = NULL,   savePlot = FALSE,   outpath = NULL,   filename = NULL,   dpi = 600,   width = 9,   height = 3,   filterForThese = NULL,   combinatorialStartsWith = NULL )"},{"path":"https://davidrach.github.io/Coereba/reference/Utility_MarkerPlots.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Takes Coereba_MarkerExpressions data.frame and returns Marker Expression Beeswarm plots — Utility_MarkerPlots","text":"data data.frame metadata summarized markers Utility_MarkerExpressions panel .csv data.frame containing Fluorophore Marker columns panel markers. myfactor column name want group outputs plot shape_palette scale manual list assigning shape factor level fill_palette scale fill list assigning fill factor level cex geom_beeswarm argument, default 1 size geom_beeswarm argument, default 1.5 corral.width geom_beeswarm argument, default 1 crossbar geom_boxplot argument, default \"median\" XAxisLevels Provide list marker names correct order x-axis reordering, default NULL savePlot Whether save ggplot object outfolder, default = FALSE outpath Specify file.path desired storage location filename Specify desired filename dpi Specify desired pixel resolution width Specify desired width inches height Specify desired height inches filterForThese list containing names markers desire include final plot, default NULL combinatorialStartsWith Default NULL, aggregated data combinatorial, starting string characters (ex. CD45)","code":""},{"path":"https://davidrach.github.io/Coereba/reference/Utility_MarkerPlots.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Takes Coereba_MarkerExpressions data.frame and returns Marker Expression Beeswarm plots — Utility_MarkerPlots","text":"Returns ggplot object R designated Folder","code":""},{"path":"https://davidrach.github.io/Coereba/reference/Utility_MarkerPlots.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Takes Coereba_MarkerExpressions data.frame and returns Marker Expression Beeswarm plots — Utility_MarkerPlots","text":"","code":"shape_ptype <- c(\"HU\" = 22, \"HEU-lo\" = 21, \"HEU-hi\" = 21) fill_ptype <- c(\"HU\" = \"white\", \"HEU-lo\" = \"darkgray\", \"HEU-hi\" = \"black\")  File_Location <- system.file(\"extdata\", package = \"Coereba\") panelPath <- file.path(File_Location, \"ILTPanelTetramer.csv\") binaryPath <- file.path(File_Location, \"HeatmapExample.csv\") dataPath <- file.path(File_Location, \"ReadyFileExample.csv\") panelData <- read.csv(panelPath, check.names=FALSE) binaryData <- read.csv(binaryPath, check.names=FALSE) dataData <- read.csv(dataPath, check.names=FALSE)  All <- Coereba_MarkerExpressions(data=dataData, binary=binaryData,  panel=panelData, starter=\"SparkBlue550\")  ThePlot <- Utility_MarkerPlots(data=All, panel=panelData,  myfactor=\"ptype\", shape_palette = shape_ptype,  fill_palette = fill_ptype, filterForThese=c(\"CD7\", \"CD4\", \"CD8\"),  XAxisLevels = c(\"CD7\", \"CD4\", \"CD8\"))"},{"path":"https://davidrach.github.io/Coereba/reference/Utility_Stats.html","id":null,"dir":"Reference","previous_headings":"","what":"Normality Test followed by t-test/Anova — Utility_Stats","title":"Normality Test followed by t-test/Anova — Utility_Stats","text":"Normality Test followed t-test/Anova","code":""},{"path":"https://davidrach.github.io/Coereba/reference/Utility_Stats.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Normality Test followed by t-test/Anova — Utility_Stats","text":"","code":"Utility_Stats(   data,   var,   myfactor,   normality = NULL,   specifiedNormality = NULL,   correction = \"none\",   override = 0.05,   returnType = \"stats\" )"},{"path":"https://davidrach.github.io/Coereba/reference/Utility_Stats.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Normality Test followed by t-test/Anova — Utility_Stats","text":"data data.frame object metadata data columns var column name variable interest myfactor column name column containing factor group normality Normality test applied, \"dagostino\" \"shapiro\". Default NULL specifiedNormality Default NULL leading non-parametric, can switch specifying \"parametric\" \"nonparametric\". correction Multiple comparison correction argument, default set \"none\" override Internal, default 0.05. Set 0.99 force pairwise comparison anova/kw. returnType Internal, default \"stats\". Alternate \"mean\", \"median\". \"behemoth\" internal usage.","code":""},{"path":"https://davidrach.github.io/Coereba/reference/Utility_Stats.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Normality Test followed by t-test/Anova — Utility_Stats","text":"data.frame test results","code":""},{"path":"https://davidrach.github.io/Coereba/reference/Utility_Stats.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Normality Test followed by t-test/Anova — Utility_Stats","text":"","code":"File_Location <- system.file(\"extdata\", package = \"Coereba\") panelPath <- file.path(File_Location, \"ILTPanelTetramer.csv\") binaryPath <- file.path(File_Location, \"HeatmapExample.csv\") dataPath <- file.path(File_Location, \"ReadyFileExample.csv\") panelData <- read.csv(panelPath, check.names=FALSE) binaryData <- read.csv(binaryPath, check.names=FALSE) dataData <- read.csv(dataPath, check.names=FALSE)  All <- Coereba_MarkerExpressions(data=dataData, binary=binaryData,  panel=panelData, starter=\"SparkBlue550\")  TheStats <- Utility_Stats(data=All, var=\"CD62L\",  myfactor=\"ptype\", normality=\"dagostino\") #> Error in if (at$p.value[1] < override) {    subset_data <- subset(data, select = c(var, myfactor))    ptt <- tidy(pairwise.t.test(subset_data[[var]], subset_data[[myfactor]],         p.adjust.method = correction))    ptt$method <- \"Pairwise t-test\"    ptt} else (at): missing value where TRUE/FALSE needed"}]
